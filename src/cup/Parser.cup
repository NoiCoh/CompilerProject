/*************/
/* Based on a template by Oren Ish-Shalom */
/*************/


/*************/
/* IMPORTS */
/*************/

import java_cup.runtime.*;
import ast.*;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;

parser code
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}

	// Override default error reporting in parser
	public void report_error(String message, Object info)
	{
	    System.err.print("Syntax error at line " + lexer.getLine() + " of input. Parser\n");
		System.exit(1);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
    try {
	s = lexer.next_token();
	// System.out.print(s.sym);
	// System.out.print("[");
	// System.out.print(lexer.getLine());
	// System.out.print(":");
	// System.out.print(lexer.getCharPos());
	// System.out.print("] ");
	// System.out.print(sym.terminalNames[s.sym]);
	// if (s.value != null)
	// {
	//	System.out.print("( ");
	//	System.out.print(s.value);
	//	System.out.print(" )");
	// }
	// System.out.print("\n");
	return s;
     } catch (java.lang.Error e) {
         System.err.print("Syntax error at line " + lexer.getLine() + " of input. Lexer\n");
         System.exit(1);
         return null;
     }
:};

/*************/
/* TERMINALS */
/*************/
terminal PUBLIC;
terminal COMMA;
terminal PLUS;
terminal MINUS;
terminal MULT;
terminal LPAREN;
terminal RPAREN;
terminal LSBRACK;
terminal RSBRACK;
terminal LCBRACK;
terminal RCBRACK;
terminal SEMICOLON;
terminal DOT;
terminal EQUAL;
terminal LT;

terminal CLASS;
terminal NEW;
terminal EXTENDS;
terminal RETURN;
terminal WHILE;
terminal IF;
terminal STRARRAY;
terminal VOID;
terminal STATIC;
terminal MAIN;

terminal NULL;
terminal String ID;
terminal Integer NUMBER;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal prog;

non terminal AstNode node;
non terminal MethodDecl methodDecl;
non terminal List<MethodDecl> list_methods;
non terminal ClassDecl classDecl;

non terminal VariableIntroduction varIntro;
non terminal VarDecl varDecl;
non terminal List<VarDecl> list_vars;

non terminal Expr expr;
non terminal Statement stmt;
non terminal RefType refType;
non terminal MainClass main;
non terminal IntAstType intType;
non terminal IntArrayAstType intArrayType;
non terminal BoolAstType boolType;


/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence left     EQUAL;
precedence left     LT;
precedence left     PLUS;
precedence left     MINUS;
precedence left     MULT;
precedence nonassoc LPAREN;
precedence nonassoc RPAREN;
precedence left     DOT;

/************************/
/* INITIAL NON TERMINAL */
/************************/
start with prog;

/********************/
/* PRODUCTION RULES */
/********************/

prog ::= node:n		{: RESULT = new Program(); :};

node ::= varIntro:d 		{: RESULT = d; :}
       | methodDecl:d   {: RESULT = d; :}
       | classDecl:d    {: RESULT = d; :}
       | main:d 		{: RESULT = d; :}
       ;
       
classDecl ::= CLASS ID:id1 LCBRACK varDecl:v list_vars:v1  methodDecl:m list_methods:m1 RCBRACK     {: RESULT = new ClassDecl(id1, null, v1,m1); :} |
           |  CLASS ID:id1 EXTENDS ID:id2 LCBRACK varDecl:v list_vars:v1  methodDecl:m list_methods:m1 RCBRACK    {: RESULT = new ClassDecl(id1, id2, v1,m1); :}
           ;
           
main ::= CLASS MAIN LCBRACK PUBLIC STATIC VOID ID:func_name LPAREN STRARRAY ID:args RPAREN LCBRACK stmt:st RCBRACK RCBRACK {: RESULT = new MainClass(func_name, args, st); :}
	;
list_vars ::= SEMICOLON varDecl:v list_vars:el {: el.add(v); RESULT = el; :}
		 | /* empty */           	{: RESULT = new ArrayList<VarDecl>(); :} 
;

list_methods ::= LCBRACK methodDecl:m list_methods:m1 {: m1.add(m); RESULT = m1; :}
		 | /* empty */           	{: RESULT = new ArrayList<MethodDecl>(); :} 
;
expr ::= expr:e1 PLUS expr:e2 		{: RESULT = new AddExpr(e1, e2); :}
         | expr:e1 MINUS expr:e2	{: RESULT = new SubtractExpr(e1, e2); :}
         | expr:e1 MULT expr:e2		{: RESULT = new MultExpr(e1, e2); :}
         | LPAREN expr:e RPAREN		{: RESULT = e; :}
         | NUMBER:n					{: RESULT = new IntegerLiteralExpr(n); :};
