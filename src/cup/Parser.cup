/*************/
/* Based on a template by Oren Ish-Shalom */
/*************/


/*************/
/* IMPORTS */
/*************/

import java_cup.runtime.*;
import ast.*;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;

parser code
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}

	// Override default error reporting in parser
	public void report_error(String message, Object info)
	{
	    System.err.print("Syntax error at line " + lexer.getLine() + " of input. Parser\n");
		System.exit(1);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
    try {
	s = lexer.next_token();
	// System.out.print(s.sym);
	// System.out.print("[");
	// System.out.print(lexer.getLine());
	// System.out.print(":");
	// System.out.print(lexer.getCharPos());
	// System.out.print("] ");
	// System.out.print(sym.terminalNames[s.sym]);
	// if (s.value != null)
	// {
	//	System.out.print("( ");
	//	System.out.print(s.value);
	//	System.out.print(" )");
	// }
	// System.out.print("\n");
	return s;
     } catch (java.lang.Error e) {
         System.err.print("Syntax error at line " + lexer.getLine() + " of input. Lexer\n");
         System.exit(1);
         return null;
     }
:};

/*************/
/* TERMINALS */
/*************/
terminal PUBLIC; 
terminal COMMA;
terminal PLUS;
terminal MINUS;
terminal MULT;
terminal LPAREN;
terminal RPAREN;
terminal LSBRACK;
terminal RSBRACK;
terminal LCBRACK;
terminal RCBRACK;
terminal SEMICOLON;
terminal DOT;
terminal EQUAL;
terminal LT;

terminal CLASS;
terminal EXTENDS;
terminal RETURN;
terminal WHILE;
terminal IF;
terminal ELSE;
terminal STRARRAY;
terminal VOID;
terminal STATIC;
terminal MAIN;
terminal String ID;
terminal Integer NUMBER;
terminal INT;
terminal BOOL;
terminal INTARRAY;
terminal NOT;
terminal AND1; 
terminal AND2; 
terminal LEN; 
terminal TRUE;
terminal FALSE;
terminal THIS;
terminal NEW;
terminal NULL;
terminal SYSOUT;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal prog;
non terminal List<ClassDecl> list_ClassDecls;
non terminal MainClass MainClass;
non terminal ClassDecl classDecl;

non terminal List<VarDecl> list_vars;
non terminal AstType declType;
non terminal VarDecl varDecl;
non terminal List<MethodDecl> list_methods;
non terminal MethodDecl methodDecl;

non terminal List<FormalArg> list_formals;
non terminal FormalArg formal;
non terminal List<Statement> list_stmts;
non terminal Statement Stmt;
non terminal Expr expr;
non terminal list_methodActuals;


/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence left     EQUAL;
precedence left     LT;
precedence left     PLUS;
precedence left     MINUS;
precedence left     MULT;
precedence nonassoc LPAREN;
precedence nonassoc RPAREN;
precedence left     DOT;

/************************/
/* INITIAL NON TERMINAL */
/************************/
start with prog;

/********************/
/* PRODUCTION RULES */
/********************/

prog ::= MainClass:main_class list_ClassDecls:list_class_decls   {: RESULT = new Program(main_class, list_class_decls); :};

list_ClassDecls  ::= list_ClassDecls:list_class_decls classDecl:c    {: list_class_decls.add(c); RESULT = list_class_decls; :}
 					|      /* empty */                                {: RESULT = new ArrayList<ClassDecl>(); :};

MainClass  ::= CLASS ID:id LCBRACK PUBLIC STATIC VOID ID:main LPAREN STRARRAY ID:args RPAREN LCBRACK Stmt:main_st RCBRACK RCBRACK {: RESULT = new MainClass(id, args, main_st); :};

classDecl ::= CLASS ID:id LCBRACK list_vars:v list_methods:m RCBRACK     {: RESULT = new ClassDecl(id,null,v,m); :} 
           |  CLASS ID:id1 EXTENDS ID:id2 LCBRACK list_vars:v list_methods:m RCBRACK    {: RESULT = new ClassDecl(id1, id2, v,m); :};          

list_vars ::= varDecl:v list_vars:vars {: vars.add(v); RESULT = vars; :}
		 | /* empty */           	{: RESULT = new ArrayList<VarDecl>(); :} ;

declType   ::= INT     {: RESULT = new IntAstType(); :}
	        |  BOOL    {: RESULT = new BoolAstType(); :}
	        |  INTARRAY {: RESULT = new IntArrayAstType(); :}
	        |  ID:ref  {: RESULT = new RefType(ref); :} ;               

varDecl   ::= declType:t ID:id SEMICOLON    {: RESULT = new VarDecl(t, id, null); :};

list_methods ::= methodDecl:m list_methods:methods {: methods.add(m); RESULT = methods; :}
		 | /* empty */           	{: RESULT = new ArrayList<MethodDecl>(); :} ;
     		 

methodDecl ::= PUBLIC declType:ret_type ID:name LPAREN RPAREN LCBRACK list_vars:vars list_stmts:stmts RETURN expr:ret RCBRACK         {: RESULT = new MethodDecl(ret_type, name,null,vars,stmts,ret,null ); :} /* without formals */
          | PUBLIC declType:ret_type ID:name LPAREN list_formals:formals RPAREN LCBRACK list_vars:vars list_stmts:stmts RETURN expr:ret RCBRACK          {: RESULT = new MethodDecl(ret_type, name, formals,vars,stmts,ret,null); :} /* with formals */
            ;

list_formals  ::= list_formals:formals COMMA formal:f    {: formals.add(f); RESULT = formals;  :}
			  | formal:f                                 {: formal=new LinkedList<FormalArg>(); formal.add(f); RESULT=formal; :}
              |     /* empty */                          {: RESULT = new ArrayList<FormalArg>(); :};

formal        ::= declType:t ID:id      {: RESULT = new FormalArg(t, id, null); :}; 

list_stmts    ::= Stmt:s list_stmts:stmts        {:  stmts.add(s); RESULT = stmts;  :}
                |     /* empty */                {: RESULT = new ArrayList<Statement>(); :};
                
Stmt          ::= ID:lv EQUAL expr:rv SEMICOLON         {: RESULT = new AssignStatement(lv,rv); :}
  				| ID:lv LSBRACK expr:i RSBRACK EQUAL expr:rv SEMICOLON {: RESULT = new AssignArrayStatement(lv, i, rv); :}
  				| LCBRACK list_vars:vars list_stmts:stmts RCBRACK      {: RESULT = new BlockStatement(stmts); :}
  				| LCBRACK list_stmts:stmts RCBRACK      {: RESULT = new BlockStatement(stmts); :}
                | IF LPAREN expr:cond RPAREN Stmt:then ELSE Stmt:else {: RESULT = new IfStatement(cond, then, else); :}
                | IF LPAREN expr:cond RPAREN Stmt:then {: RESULT = new IfStatement(cond, then, null); :}
                | WHILE LPAREN expr:cond RPAREN Stmt:s {: RESULT = new WhileStatement(cond, s); :}
                | SYSOUT LPAREN expr:e RPAREN SEMICOLON  {: RESULT = new SysoutStatement(e); :};
              
               
expr ::= expr:e1 PLUS expr:e2 		{: RESULT = new AddExpr(e1, e2); :}
         | expr:e1 MINUS expr:e2	{: RESULT = new SubtractExpr(e1, e2); :}
         | expr:e1 MULT expr:e2		{: RESULT = new MultExpr(e1, e2); :}
         | LPAREN expr:e RPAREN		{: RESULT = e; :}
         | NUMBER:n					{: RESULT = new IntegerLiteralExpr(n.intValue()); :}
         | NOT:not expr:e           {: RESULT = new NotExpr(e); :}
         | expr:e1 AND1 expr:e2     {: RESULT = new AndExpr(e1, e2); :}
         | expr:e1 AND2 expr:e2     {: RESULT = new AndExpr(e1, e2); :}
	     | expr:e1 LT expr:e2       {: RESULT = new LtExpr(e1, e2); :}
	     | expr:arr LSBRACK expr:i RSBRACK   {: RESULT = new ArrayAccessExpr(arr, i); :}
	     | expr:arr DOT LEN         {: RESULT = new ArrayLengthExpr(arr); :}
	     | expr:owner DOT ID:id LPAREN list_methodActuals:actuals RPAREN {: RESULT = new MethodCallExpr(owner, id, actuals); :
	     | TRUE  {: RESULT = new TrueExpr(); :}
	     | FALSE {: RESULT = new FalseExpr(); :}
	     | ID:id  {: RESULT = new IdentifierExpr(id); :}
	     | THIS   {: RESULT = new ThisExpr(); :}
	     | NEW INT LSBRACK Expr:e RSBRACK        {: RESULT = new NewIntArrayExpr(e); :}
	     | NEW ID:id LPAREN RPAREN               {: RESULT = new NewObjectExpr(id); :};
	        

list_methodActuals  ::= expr:e COMMA list_methodActuals:actuals   {:list_methodActuals.add(e) ;RESULT = list_methodActuals; :};
					|   expr:e                               {: actual=new LinkedList<Expr>(); actual.add(e); RESULT=actual  :};
					| /* empty */                            {: RESULT = new ArrayList<Expr>(); :}
   

 